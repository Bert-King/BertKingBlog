---
title: 二叉树路径相关题目
date: 2022-01-13
author: Bertking
tags:
  - 算法
  - 二叉树
  - 路径
---

# 1. 路径相关的题目

[257. 二叉树的所有路径 - E](https://leetcode-cn.com/problems/binary-tree-paths/)
> 所有从根节点到叶子节点的路径

[113. 路径总和 II - M](https://leetcode-cn.com/problems/path-sum-ii/)
> 求满足条件的所有路径(从根节点到叶子节点)

[112. 路径总和 - E](https://leetcode-cn.com/problems/path-sum/)
> 从根节点到叶子节点 路径总和等于给定目标和的路径。

[988. 从叶结点开始的最小字符串 - M](https://leetcode-cn.com/problems/smallest-string-starting-from-leaf/)
> 求所有路径中的最小字符串(从叶子节点开始)

[129. 求根节点到叶节点数字之和 - M](https://leetcode-cn.com/problems/sum-root-to-leaf-numbers/)

[437. 路径总和 III - M](https://leetcode-cn.com/problems/path-sum-iii/)
> 路径: 不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。


# 2. 解题思路
关于二叉树**路径**的题目，首先要明确一点:
> 是否是从(根节点->叶子节点 || 叶子节点->根节点)

## 2.1 根节点-->叶子节点

### 2.1.1 二叉树的所有路径(根->叶子)

[257. 二叉树的所有路径 - E](https://leetcode-cn.com/problems/binary-tree-paths/) 

> 这道题是用String来表示路径的。(为了效率可以采用StringBuilder)

```java
    public class Solution{

        List<String> result = new ArrayList();

        public List<String> binaryTreePaths(TreeNode root) {

            dfs(root,new StringBuilder());

            return result;
        }
        // 根->叶。 DFS完美
        public void dfs(TreeNode root, StringBuilder path){
            if(root == null){
                return ;
            }

            path.append(root.val);
            if(root.left == null && root.right == null){
                result.add(path.toString());
            }
            
            path.append("->");
            // 有些同学，可能出于优化代码的角度，想把new StringBuilde(path)也提取出来，这个不可以的，
            dfs(root.left, new StringBuilder(path));

            dfs(root.right,new StringBuilder(path));
        }

    }
```
---
[113. 路径总和 II - M](https://leetcode-cn.com/problems/path-sum-ii/)
> 求满足条件的所有路径(从根节点到叶子节点)

这道题和[257](https://leetcode-cn.com/problems/binary-tree-paths/) 基本一样，区别在于用List来代表路径。解法自然是一样。

```java
public class Solution{
    
    List<List<Integer>> result = new ArrayList();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        
        dfs(root,new ArrayList(),targetSum);
        
        return result;
    }

    public void dfs(TreeNode root,List<Integer> path,int targetSum){
        if(root == null){
            return;
        }
        path.add(root.val);
        targetSum -= root.val;

        if(root.left == null && root.right == null && targetSum == 0){
            result.add(path);
        }

        // 这里我们发现遍历左右子树，都得重新构建路径，还能优化。
        dfs(root.left, new ArrayList(path),targetSum);

        dfs(root.right,new ArrayList(path),targetSum);
    }

}

```

> 上面的解法遍历左右子树都得重新构建路径，这里进行优化一下：
>
> 只在添加的时候构建路径。

具体做法如下:

```java
public class Solution{

    List<List<Integer>> result = new ArrayList();

    List<Integer> path = new ArrayList();

    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {
        dfs(root,targetSum);
        return result;
    }

    public dfs(TreeNode root, int targetSum){
        if(root == null) return ;

        targetSum -= root.val;
        path.add(root.val);

        if(root.left == null && root.right == null && targetSum == 0){
            result.add(new Array(path));
        }

        dfs(root.left,targetSum);
        dfs(root.right,targetSum);
        // 这个地方很容易忽略, 向上回溯
        path.remove(path.size()-1);

    }
}
```